#lang racket
(define (empty-dict) '())
(define (ext-dict key val dict)
  (cons (list key val) dict))
(define (lookup key dict)
  (assq key dict))
(define (bd-val bd) (cadr bd))
;<var> ::= (? <symbol>)
;<seg-var> ::= (?? <symbol>)
(define (var-id v) (cadr v))
;<const> ::= <number>
;         |  <boolean>
;         |  <symbol>
(define (const? x)
  (or (number? x)
      (boolean? x)
      (symbol? x)))
(define (Const c)
  (lambda (x* dict succ fail)
    (cond ((null? x*) (fail))
          ((eqv? (car x*) c)
           (succ (cdr x*) dict fail))
          (else (fail)))))
(define (Var id)
  (lambda (x* dict succ fail)
    (if (null? x*)
        (fail)
        (let ((bd (lookup id dict)))
          (if bd
              (let ((val (bd-val bd)))
                (if (equal? val (car x*))
                    (succ (cdr x*) dict fail)
                    (fail)))
              (succ (cdr x*)
                    (ext-dict id (car x*) dict)
                    fail))))))
(define (Seq2 m1 m2)
  (lambda (x* dict succ fail)
    (m1 x* dict
        (lambda (x* dict fail)
          (m2 x* dict succ fail))
        fail)))
(define (Succ)
  (lambda (x* dict succ fail)
    (succ x* dict fail)))
(define (Fail)
  (lambda (x* dict succ fail)
    (fail)))
(define (Seq . m*)
  (if (null? m*)
      (Succ)
      (let iter ((m (car m*))
                 (m* (cdr m*)))
        (if (null? m*)
            m
            (iter (Seq2 m (car m*))
                  (cdr m*))))))
(define (List . m*)
  (let ((m (apply Seq m*)))
    (lambda (x* dict succ fail)
      (if (null? x*)
          (fail)
          (let ((x (car x*))
                (x* (cdr x*)))
            (if (or (null? x) (pair? x))
                (m x dict
                   (lambda (rest dict fail)
                     (if (null? rest)
                         (succ x* dict fail)
                         (fail)))
                   fail)
                (fail)))))))
(define (Seg-var id)
  (lambda (x* dict succ fail)
    (let ((bd (lookup id dict)))
      (if bd
          (let ((y* (bd-val bd)))
            (let iter ((y* y*) (x* x*))
              (cond ((null? y*) (succ x* dict fail))
                    ((null? x*) (fail))
                    ((equal? (car y*) (car x*))
                     (iter (cdr y*) (cdr x*)))
                    (else (fail)))))
          (let iter ((y* '()) (x* x*))
            (succ x* (ext-dict id y* dict)
                  (lambda ()
                    (if (null? x*)
                        (fail)
                        (iter (attach y* (car x*))
                              (cdr x*))))))))))
(define (attach l x)
  (append l (list x)))
;<pattern> ::= <const>
;           |  <var>
;           |  (list <pat>*)
;<pat> ::= <const>
;       |  <var>
;       |  <seg-var>
;       |  (list <pat>*)
(define (compile-pattern p)
  (define (Pattern p)
    (if (const? p)
        (Const p)
        (case (car p)
          ((?) (Var (var-id p)))
          ((list)
           (apply List (map Pat (cdr p)))))))
  (define (Pat p)
    (if (const? p)
        (Const p)
        (case (car p)
          ((?) (Var (var-id p)))
          ((??) (Seg-var (var-id p)))
          ((list)
           (apply List (map Pat (cdr p)))))))
  (Pattern p))