#lang racket
(define (interleave x y)
  (if (null? x)
      '()
      (cons (car x)
            (cons (car y)
                  (interleave (cdr x) (cdr y))))))
(define (evens x)
  (if (null? x)
      '()
      (cons (car x)
            (evens (cddr x)))))
(define (split x)
  (let recur ((slow x) (fast x))
    (if (null? fast)
        (values '() slow)
        (let-values (((front back) (recur (cdr slow) (cddr fast))))
          (values (cons (car slow) front) back)))))
(define (w-powers n)
  (define Δ (/ (* -2i pi) n))
  (let recur ((x 0) (c 0))
    (if (= c n)
        '()
        (cons (exp x)
              (recur (+ x Δ) (+ c 2))))))
(define (butterfly x w)
  (let-values (((y z) (split x)))
    (values
     (map + y z)
     (map (lambda (a b c)
            (* (- a b) c))
          y z w))))
(define (fft x)
  (define (recur x 2w)
    (if (null? (cdr x))
        x
        (let ((w (evens 2w)))
          (let-values (((y z) (butterfly x w)))
            (interleave (recur y w) (recur z w))))))
  (if (null? (cdr x))
      x
      (let ((w (w-powers (length x))))
        (let-values (((y z) (butterfly x w)))
          (interleave (recur y w) (recur z w))))))
#;
(define (fft x)
  (let recur ((x x) (w (w-powers (length x))))
    (if (null? (cddr x))
        (let ((x0 (car x)) (x1 (cadr x)))
          (list (+ x0 x1) (- x0 x1)))
        (let-values (((y z) (butterfly x w)))
          (let ((w (evens w)))
            (interleave (recur y w) (recur z w)))))))