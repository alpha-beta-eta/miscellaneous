#lang racket
(require "match.rkt")
;<exp> ::= zero
;       |  one
;       |  <char>
;       |  (plus <exp> <exp>)
;       |  (times <exp> <exp>)
;       |  (star <exp>)
(define zero 'zero)
(define one 'one)
(define (plus e1 e2)
  (cond ((eq? e1 zero) e2)
        ((eq? e2 zero) e1)
        (else `(plus ,e1 ,e2))))
(define (times e1 e2)
  (cond ((eq? e1 zero) zero)
        ((eq? e2 zero) zero)
        ((eq? e1 one) e2)
        ((eq? e2 one) e1)
        (else `(times ,e1 ,e2))))
(define (star exp)
  (cond ((eq? exp zero) one)
        ((eq? exp one) one)
        (else `(star ,exp))))
(define (delta? exp)
  (match exp
    (zero #f)
    (one #t)
    (,c (guard (char? c)) #f)
    ((plus ,e1 ,e2)
     (or (delta? e1) (delta? e2)))
    ((times ,e1 ,e2)
     (and (delta? e1) (delta? e2)))
    ((star ,e) #t)))
(define (empty? exp)
  (match exp
    (zero #t)
    (one #f)
    (,c (guard (char? c)) #f)
    ((plus ,e1 ,e2)
     (and (empty? e1) (empty? e2)))
    ((times ,e1 ,e2)
     (or (empty? e1) (empty? e2)))
    ((star ,e) #f)))
(define (D exp c)
  (match exp
    (zero zero)
    (one zero)
    (,c^
     (guard (char? c^))
     (if (char=? c^ c) one zero))
    ((plus ,e1 ,e2)
     (plus (D e1 c) (D e2 c)))
    ((times ,e1 ,e2)
     (define e3
       (times (D e1 c) e2))
     (if (delta? e1)
         (plus e3 (D e2 c))
         e3))
    ((star ,e)
     (times (D e c) (star e)))))
(define (in? str exp)
  (define l (string-length str))
  (let iter ((i 0) (exp exp))
    (cond ((= i l) (delta? exp))
          ((empty? exp) #f)
          (else
           (iter (+ i 1)
                 (D exp (string-ref str i)))))))