#lang racket
(provide (all-defined-out))
(require "vector.rkt")
(define (build-matrix i j p)
  (build-vector
   i (lambda (i)
       (build-vector
        j (lambda (j) (p i j))))))
(define (matrix l)
  (apply vector (map (lambda (r) (apply vector r)) l)))
(define (nrows m)
  (vector-length m))
(define (ncols m)
  (vector-length (vector-ref m 0)))
(define (print-matrix m)
  (define (print-row r)
    (vector-for-each
     (lambda (x)
       (printf "~s " x)) r)
    (newline))
  (vector-for-each print-row m))
(define (row-ref m i)
  (vector-ref m i))
(define (matrix-ref m i j)
  (vector-ref (vector-ref m i) j))
(define (matrix-set! m i j x)
  (vector-set! (vector-ref m i) j x))
(define (matrix-copy m)
  (vector-map vector-copy m))
(define (matrix-map p m)
  (vector-map (lambda (row) (vector-map p row)) m))
(define (matrix-mapij p m)
  (vector-mapi
   (lambda (row i)
     (vector-mapi
      (lambda (x j)
        (p x i j))
      row))
   m))
(define (transpose m)
  (build-matrix
   (ncols m) (nrows m)
   (lambda (i j)
     (matrix-ref m j i))))
(define (m* m1 m2)
  (define R1 (nrows m1))
  (define C1 (ncols m1))
  (define R2 (nrows m2))
  (define C2 (ncols m2))
  (unless (= C1 R2)
    (error 'm* "mismatch"))
  (build-matrix
   R1 C2
   (lambda (i j)
     (Sigma (lambda (k)
              (* (matrix-ref m1 i k)
                 (matrix-ref m2 k j)))
            0 (- C1 1)))))
(define (m+ m1 m2)
  (define R1 (nrows m1))
  (define C1 (ncols m1))
  (define R2 (nrows m2))
  (define C2 (ncols m2))
  (unless (and (= R1 R2) (= C1 C2))
    (error 'm+ "mismatch"))
  (build-vector
   R1 (lambda (i)
        (vector-add
         (row-ref m1 i)
         (row-ref m2 i)))))
(define (m- m1 m2)
  (define R1 (nrows m1))
  (define C1 (ncols m1))
  (define R2 (nrows m2))
  (define C2 (ncols m2))
  (unless (and (= R1 R2) (= C1 C2))
    (error 'm- "mismatch"))
  (build-vector
   R1 (lambda (i)
        (vector-sub
         (row-ref m1 i)
         (row-ref m2 i)))))
(define (k*m k m)
  (matrix-map (lambda (x) (* k x)) m))
(define (delta i j)
  (if (= i j) 1 0))
(define (I n)
  (build-matrix n n delta))
;erop: elementary row operation
(define (erop1 m r k)
  (scalar-mul! k (row-ref m r))
  (unless (= k 1)
    (printf "将第~s行乘上~s\n" (+ r 1) k)
    (print-matrix m)))
(define (erop2 m r1 k r2)
  (vector-set!
   m r2
   (vector-add
    (scalar-mul k (row-ref m r1))
    (row-ref m r2)))
  (unless (= k 0)
    (printf "将第~s行乘上~s加到第~s行\n" (+ r1 1) k (+ r2 1))
    (print-matrix m)))
(define (erop3 m r1 r2)
  (vector-swap! m r1 r2)
  (unless (= r1 r2)
    (printf "交换第~s行和第~s行\n" (+ r1 1) (+ r2 1))
    (print-matrix m)))
(define (row-echelonize! m)
  (define R (nrows m))
  (define C (ncols m))
  (let iter ((i 0) (j 0))
    (unless (or (= i R) (= j C))
      (let find-r ((r i))
        (cond
          ((= r R) (iter i (+ j 1)))
          ((= (matrix-ref m r j) 0) (find-r (+ r 1)))
          (else
           (erop3 m i r)
           (let ((x (matrix-ref m i j)))
             (let Iter ((k (+ i 1)))
               (unless (= k R)
                 (erop2 m i (- (/ (matrix-ref m k j) x)) k)
                 (Iter (+ k 1)))))
           (iter (+ i 1) (+ j 1))))))))
(define (first-nonzero v)
  (define l (vector-length v))
  (let iter ((i 0))
    (cond ((= i l) #f)
          ((= (vector-ref v i) 0)
           (iter (+ i 1)))
          (else i))))
(define (reduce-row-echelon! m)
  (define R (vector-length m))
  (let iter ((i (- R 1)))
    (unless (= i -1)
      (define row (row-ref m i))
      (define j (first-nonzero row))
      (when j
        (erop1 m i (/ 1 (vector-ref row j)))
        (let Iter ((k (- i 1)))
          (unless (= k -1)
            (erop2 m i (- (matrix-ref m k j)) k)
            (Iter (- k 1)))))
      (iter (- i 1)))))
(define (rref! m)
  (print-matrix m)
  (row-echelonize! m)
  (reduce-row-echelon! m))